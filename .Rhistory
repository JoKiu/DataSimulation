?commandArgs
#Data simulation
#
if(is.na(seed)){seed <- 1}
cat(sprintf(" - Running the script with seed %d.\n", seed))
########################################
## Parameter
########################################
n <- 3000
n_train <- n / 2
n_calib <- n / 2
n_test <- 3000
p <- 100
beta <- 30 / sqrt(n)
xnames <- paste0("X",1:p)
c_ref <-1 : 6 / 2
exp_rate <- 0.4
alpha_list <- 0.1
########################################
## Data generating models
########################################
mu_x <- function(x) beta * x[,1]^2 - beta * x[,3] * x[,5] + 1
sigma_x <- function(x) (abs(x[,10]) + 1)
gen_t <- function(x) 2 * exp(mu_x(x) + sigma_x(x) * rnorm(dim(x)[1]))
gen_c <- function(x) rexp(rate = exp_rate, n = dim(x)[1])
## Generate training data
set.seed(24601)
X <- matrix(runif(n_train * p, min = -1, max = 1), n_train)
T <- gen_t(X)
C <- gen_c(X)
event <- (T<C)
censored_T <- pmin(T,C)
data_fit <- data.frame(X, C = C, censored_T = censored_T, event = event)
colnames(data_fit) <- c(xnames, "C", "censored_T", "event")
########################################
## Generate the calibration data and the test data
########################################
set.seed(seed)
X <- matrix(runif((n_calib + n_test) * p, min = -1, max = 1), n_calib + n_test)
T <- gen_t(X)
C <- gen_c(X)
event <- (T<C)
censored_T <- pmin(T,C)
data <- data.frame(X, C = C, censored_T = censored_T,  event = event)
colnames(data) <- c(xnames, "C", "censored_T", "event")
data_calib <- data[1:n_calib,]
data_test <- data[(n_calib+1) : (n_calib+n_test),]
data <- rbind(data_fit,data_calib)
#Data simulation
#
if(is.na(seed)){seed <- 1}
#Data simulation
#
seed <- 1
########################################
## Parameter
########################################
n <- 3000
n_train <- n / 2
n_calib <- n / 2
n_test <- 3000
p <- 100
beta <- 30 / sqrt(n)
xnames <- paste0("X",1:p)
c_ref <-1 : 6 / 2
exp_rate <- 0.4
alpha_list <- 0.1
########################################
## Data generating models
########################################
mu_x <- function(x) beta * x[,1]^2 - beta * x[,3] * x[,5] + 1
sigma_x <- function(x) (abs(x[,10]) + 1)
gen_t <- function(x) 2 * exp(mu_x(x) + sigma_x(x) * rnorm(dim(x)[1]))
gen_c <- function(x) rexp(rate = exp_rate, n = dim(x)[1])
## Generate training data
set.seed(24601)
X <- matrix(runif(n_train * p, min = -1, max = 1), n_train)
T <- gen_t(X)
C <- gen_c(X)
event <- (T<C)
censored_T <- pmin(T,C)
data_fit <- data.frame(X, C = C, censored_T = censored_T, event = event)
colnames(data_fit) <- c(xnames, "C", "censored_T", "event")
########################################
## Generate the calibration data and the test data
########################################
set.seed(seed)
X <- matrix(runif((n_calib + n_test) * p, min = -1, max = 1), n_calib + n_test)
T <- gen_t(X)
C <- gen_c(X)
event <- (T<C)
censored_T <- pmin(T,C)
data <- data.frame(X, C = C, censored_T = censored_T,  event = event)
colnames(data) <- c(xnames, "C", "censored_T", "event")
data_calib <- data[1:n_calib,]
data_test <- data[(n_calib+1) : (n_calib+n_test),]
data <- rbind(data_fit,data_calib)
#Data simulation
#
rm(list=ls())
#Data simulation
#
rm(list=ls())
seed <- 1
########################################
## Parameter
########################################
n <- 3000
n_train <- n / 2
n_calib <- n / 2
n_test <- 3000
beta <- 20 / sqrt(n)
c_ref <- 1 : 6 / 2
xmin <- 0; xmax <- 4
exp_rate <- 0.4
pr_all_list <- matrix(0, n+n_test, length(c_ref))
alpha_list <- 0.1
########################################
## Data generating models
########################################
gen_t <- function(x) exp(2 + beta * sqrt(abs(x)) +  1.5 * rnorm(length(x)))
gen_c <- function(x) rexp(rate = exp_rate, n = length(x))
########################################
## Generate training data
########################################
set.seed(24601)
X <- runif(n_train, xmin, xmax)
T <- gen_t(X)
C <- gen_c(X)
event <- (T < C)
censored_T <- pmin(T, C)
data_fit <- data.frame(X1 = X, C = C, censored_T = censored_T, event = event)
########################################
## Generate the calibration data and the test data
########################################
set.seed(seed)
X <- runif(n_calib + n_test, xmin, xmax)
T <- gen_t(X)
C <- gen_c(X)
event <- (T < C)
censored_T <- pmin(T, C)
data <- data.frame(X1 = X, C = C, event = event, censored_T = censored_T)
data_calib <- data[1 : n_calib, ]
data_test <- data[(n_calib + 1) : (n_calib + n_test), ]
data <- rbind(data_fit, data_calib)
data <- rbind(data_fit,data_calib)
########################################
## Generate the calibration data and the test data
########################################
?flush.console
table(data_fit$event)
table(data_fit$event)[1]
#Data simulation
#
rm(list=ls())
seed <- 1
########################################
## Parameter
########################################
n <- 3000
n_train <- n / 2
n_calib <- n / 2
n_test <- 3000
beta <- 20 / sqrt(n)
xmin <- 0; xmax <- 4
exp_rate <- 0.4
alpha <- 0.05
########################################
## Data generating models
########################################
gen_t <- function(x) exp(2 + beta * sqrt(abs(x)) +  1.5 * rnorm(length(x)))
gen_c <- function(x) rexp(rate = exp_rate, n = length(x))
########################################
## Generate training data
########################################
set.seed(24601)
X <- runif(n_train, xmin, xmax)
T <- gen_t(X)
C <- gen_c(X)
event <- (T < C)
censored_T <- pmin(T, C)
data_fit <- data.frame(X1 = X, C = C, censored_T = censored_T, event = event)
########################################
## Generate the calibration data and the test data
########################################
set.seed(seed)
X <- runif(n_calib + n_test, xmin, xmax)
T <- gen_t(X)
C <- gen_c(X)
event <- (T < C)
censored_T <- pmin(T, C)
data <- data.frame(X1 = X, C = C, event = event, censored_T = censored_T)
data_calib <- data[1 : n_calib, ]
data_test <- data[(n_calib + 1) : (n_calib + n_test), ]
data <- rbind(data_fit, data_calib)
data <- rbind(data_fit,data_calib)
########################################
## determine alpha
########################################
gamma=table(data_fit$event)[1]/nrow(data_fit)
alpha = alpha/gamma
########################################
## implement distribution tree: full conformal inference
########################################
out = train.fun(x,y)
fit = matrix(predict.fun(out,x),nrow=n)
pred = matrix(predict.fun(out,x0),nrow=n0)
m = ncol(pred)
# Trial values for y, empty lo, up matrices to fill
ymax = max(abs(y))
yvals = seq(-grid.factor*ymax, grid.factor*ymax,length=num.grid.pts)
lo = up = matrix(0,n0,m)
qvals = rvals = matrix(0,num.grid.pts,m)
xx = rbind(x,rep(0,p))
for (i in 1:n0) {
if (verbose) {
cat(sprintf("\r%sProcessing prediction point %i (of %i) ...",txt,i,n0))
flush.console()
}
xx[n+1,] = x0[i,]
ww = c(w[1:n],w[n+i])
# Refit for each point in yvals, compute conformal p-value
for (j in 1:num.grid.pts) {
yy = c(y,yvals[j])
if (j==1) out = train.fun(xx,yy)
else out = train.fun(xx,yy,out)
r = abs(yy - matrix(predict.fun(out,xx),nrow=n+1))
# Local scoring?
if (!is.null(mad.train.fun) && !is.null(mad.predict.fun)) {
for (l in 1:m) {
if (j==1 && l==1) out.mad = mad.train.fun(xx,r[,l])
else out.mad = mad.train.fun(xx,r[,l],out.mad)
r[,l] = r[,l] / mad.predict.fun(out.mad,xx)
}
}
qvals[j,] = apply(r,2,weighted.quantile,prob=1-alpha,w=ww)
rvals[j,] = r[n+1,]
}
for (l in 1:m) {
int = grid.interval(yvals,rvals[,l],qvals[,l])
lo[i,l] = int$lo
up[i,l] = int$up
}
}
if (verbose) cat("\n")
return(list(pred=pred,lo=lo,up=up,fit=fit))
rm(list=ls())
seed <- 1
########################################
## Parameter
########################################
n <- 3000
n_train <- n / 2
n_calib <- n / 2
n_test <- 3000
beta <- 20 / sqrt(n)
xmin <- 0; xmax <- 4
exp_rate <- 0.4
alpha <- 0.05
########################################
## Data generating models
########################################
gen_t <- function(x) exp(2 + beta * sqrt(abs(x)) +  1.5 * rnorm(length(x)))
gen_c <- function(x) rexp(rate = exp_rate, n = length(x))
########################################
## Generate training data
########################################
set.seed(24601)
X <- runif(n_train, xmin, xmax)
T <- gen_t(X)
C <- gen_c(X)
event <- (T < C)
censored_T <- pmin(T, C)
data_fit <- data.frame(X1 = X, C = C, censored_T = censored_T, event = event)
########################################
## Generate the calibration data and the test data
########################################
set.seed(seed)
X <- runif(n_calib + n_test, xmin, xmax)
T <- gen_t(X)
C <- gen_c(X)
event <- (T < C)
censored_T <- pmin(T, C)
data <- data.frame(X1 = X, C = C, event = event, censored_T = censored_T)
data_calib <- data[1 : n_calib, ]
data_test <- data[(n_calib + 1) : (n_calib + n_test), ]
data <- rbind(data_fit, data_calib)
data <- rbind(data_fit,data_calib)
########################################
## determine alpha
########################################
gamma=table(data_fit$event)[1]/nrow(data_fit)
alpha = alpha/gamma
########################################
## set up x and y
########################################
x <- data_fit$X1[which(data_fit$event==F)]
y <- data_fit$C[which(data_fit$event==F)]
?chol()
View(data)
########################################
## set up training and prediction functions
########################################
library(conformalInference)
my.lm.funs = lm.funs(lambda=lambda)
lambda<-0#ridge regression
########################################
## set up training and prediction functions
########################################
library(conformalInference)
my.lm.funs = lm.funs(lambda=lambda)
my.conf.fun = function(x, y, x0) {
conformal.pred(x,y,x0,alpha=alpha,verb="\t\t",
train.fun=my.lm.funs$train,
predict.fun=my.lm.funs$predict)
}
nrow(x0)
#Data simulation
#
rm(list=ls())
seed <- 1
########################################
## Parameter
########################################
n <- 3000
n_train <- n / 2
n_calib <- n / 2
n_test <- 3000
beta <- 20 / sqrt(n)
xmin <- 0; xmax <- 4
exp_rate <- 0.4
alpha <- 0.05
########################################
## Data generating models
########################################
gen_t <- function(x) exp(2 + beta * sqrt(abs(x)) +  1.5 * rnorm(length(x)))
gen_c <- function(x) rexp(rate = exp_rate, n = length(x))
########################################
## Generate training data
########################################
set.seed(24601)
X <- runif(n_train, xmin, xmax)
T <- gen_t(X)
C <- gen_c(X)
event <- (T < C)
censored_T <- pmin(T, C)
data_fit <- data.frame(X1 = X, C = C, censored_T = censored_T, event = event)
########################################
## Generate the calibration data and the test data
########################################
set.seed(seed)
X <- runif(n_calib + n_test, xmin, xmax)
T <- gen_t(X)
C <- gen_c(X)
event <- (T < C)
censored_T <- pmin(T, C)
data <- data.frame(X1 = X, C = C, event = event, censored_T = censored_T)
data_calib <- data[1 : n_calib, ]
data_test <- data[(n_calib + 1) : (n_calib + n_test), ]
data <- rbind(data_fit, data_calib)
########################################
## determine alpha
########################################
gamma=table(data$event)[1]/nrow(data)
alpha = alpha/gamma
########################################
## preparing parameters for distribution free conformal methods
########################################
x <- data$X1[which(data$event==F)]
y <- data$C[which(data$event==F)]
x0<- data_test$X1[which(data_test$event==F)]
y0<- data_test$C[which(data_test$event==F)]
lambda<-0#ridge regression
library(conformalInference)
my.lm.funs = lm.funs(lambda=lambda)
my.conf.fun = function(x, y, x0) {
conformal.pred(x,y,x0,alpha=alpha,verb="\t\t",
train.fun=my.lm.funs$train,
predict.fun=my.lm.funs$predict)
}
########################################
## implement distribution tree: full conformal inference
########################################
out = my.conf.fun(x,y)
my.conf.fun(x,y,x0)
my.conf.fun(x,y,x0)->test
View(test)
#Data simulation
#
rm(list=ls())
seed <- 1
########################################
## Parameter
########################################
n <- 3000
n_train <- n / 2
n_calib <- n / 2
n_test <- 3000
beta <- 20 / sqrt(n)
xmin <- 0; xmax <- 4
exp_rate <- 0.4
alpha <- 0.05
########################################
## Data generating models
########################################
gen_t <- function(x) exp(2 + beta * sqrt(abs(x)) +  1.5 * rnorm(length(x)))
gen_c <- function(x) rexp(rate = exp_rate, n = length(x))
########################################
## Generate training data
########################################
set.seed(24601)
X <- runif(n_train, xmin, xmax)
T <- gen_t(X)
C <- gen_c(X)
event <- (T < C)
censored_T <- pmin(T, C)
data_fit <- data.frame(X1 = X, C = C, censored_T = censored_T, event = event)
########################################
## Generate the calibration data and the test data
########################################
set.seed(seed)
X <- runif(n_calib + n_test, xmin, xmax)
T <- gen_t(X)
C <- gen_c(X)
event <- (T < C)
censored_T <- pmin(T, C)
data <- data.frame(X1 = X, C = C, event = event, censored_T = censored_T)
data_calib <- data[1 : n_calib, ]
data_test <- data[(n_calib + 1) : (n_calib + n_test), ]
data <- rbind(data_fit, data_calib)
########################################
## determine alpha
########################################
gamma=table(data$event)[1]/nrow(data)
alpha = alpha/gamma
########################################
## preparing parameters for distribution free conformal methods
########################################
x <- data$X1[which(data$event==F)]
y <- data$C[which(data$event==F)]
x0<- data_test$X1[which(data_test$event==F)]
y0<- data_test$C[which(data_test$event==F)]
lambda<-0#ridge regression
########################################
## set up training and prediction functions
########################################
library(conformalInference)
my.lm.funs = lm.funs(lambda=lambda)
my.conf.fun = function(x, y, x0) {
conformal.pred(x,y,x0,alpha=alpha,verb="\t\t",
train.fun=my.lm.funs$train,
predict.fun=my.lm.funs$predict)
}
pred_out<-my.conf.fun(x,y,x0)
mean(y0>pred_out$lo)
y0>pred_out$lo
mean(y0>pred_out$lo&y0<pred_out$up)
y0<pred_out$up
mean(y0>pred_out$lo&y0<pred_out$up)
